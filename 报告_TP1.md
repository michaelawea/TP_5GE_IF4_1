# IF4 TP1 实验报告

**学生姓名：** [在此填写姓名]  
**日期：** 2025年10月24日

---

## 2.1 并发任务

### 2.1.1 第一次尝试

**程序：** IF4_TP1_Q21a.ino

#### 问题1：简要描述程序实现的功能和在示波器上获得的结果。解释为什么会得到这个结果。

该程序创建了两个并发任务，任务1（优先级1）控制GPIO 19引脚，任务2（优先级10）控制GPIO 23引脚，两个任务都在无限循环中不断切换其对应引脚的状态。通过示波器观察发现，无论是GPIO 19还是GPIO 23引脚，都能测量到非常正常的高频方波信号，两个任务都能正常执行。从串口日志可以看到，虽然两个任务启动时都在core 1，但运行时FreeRTOS将它们调度到了不同的核心（vTask1在CPU 0，vTask2在CPU 1），因此每个任务都能在各自的核心上独立运行，不会因为优先级差异而导致低优先级任务被"饥饿"

---

#### 问题2：打开串口监视器，你观察到了什么？为什么？

在串口监视器中观察到程序启动时打印"Start"、"vTask1 / core 1 started"和"vTask2 / core 1 started"，两个任务初始都在core 1上创建。约10秒后出现看门狗超时错误"E (10120) task_wdt: Task watchdog got triggered"，错误信息显示当前CPU 0运行vTask1，CPU 1运行vTask2，说明运行过程中FreeRTOS将两个任务调度到了不同的核心上。看门狗错误的原因是两个任务在无限循环中持续占用各自的CPU核心而没有任何延迟操作，导致CPU 0上的空闲任务IDLE0无法执行来喂看门狗，最终触发看门狗复位。在看门狗触发前的10秒内两个任务能正常运行在不同核心上并切换GPIO状态，这解释了为什么在示波器上能观察到两个引脚都有正常的方波信号

---

### 2.1.2 两个并发任务，变体

**程序：** IF4_TP1_Q21b.ino

#### 问题1：与前一个程序有什么区别？

与Q21a程序相比，主要区别在于Q21b使用了`xTaskCreatePinnedToCore()`函数强制将两个任务都固定分配到core 0上运行，而不是让FreeRTOS自动调度任务到不同核心。此外，两个任务的GPIO引脚分配交换了（oscillo1=23，oscillo2=19），并且在每个任务的无限循环中增加了一个内部for循环来连续切换1000次引脚状态。

#### 问题2：通过示波器和串口监视器观察，对运行有什么影响？

通过示波器观察到GPIO 19（channel 1）有正常的方波信号，但GPIO 23完全没有信号输出。串口日志显示只有"[INFO] vTask2 / core 0 started"，没有看到vTask1的启动信息，并且约10秒后出现看门狗错误"E (10118) task_wdt: Task watchdog got triggered"，错误信息显示CPU 0运行Task2，CPU 1运行IDLE1空闲任务。这说明高优先级的Task2（优先级10）完全占用了core 0，导致低优先级的Task1（优先级1）根本无法得到执行机会，甚至连启动信息都没有打印出来。由于Task1控制GPIO 23，所以在示波器上看不到该引脚的任何信号。这就是典型的任务"饥饿"现象：当两个不同优先级的任务被强制在同一个核心上运行时，低优先级任务会被高优先级任务完全阻塞而无法执行。

#### 问题3：如何避免这个问题？

避免任务饥饿问题的方法很简单，就是修改`xTaskCreatePinnedToCore()`函数的最后一个参数，将两个任务分配到不同的核心上运行。具体做法是将一个任务的核心参数设为0，另一个设为1，这样Task1在core 0上运行，Task2在core 1上运行，两个任务就可以并行执行而不会相互阻塞。此外，也可以使用普通的`xTaskCreate()`函数让FreeRTOS自动进行核心分配。另一种方法是在高优先级任务中添加延迟函数（如`vTaskDelay()`），让出CPU时间给低优先级任务执行，但这种方法不如多核分配效果好。

#### 问题4：修改两个任务的优先级，将它们设置为相同的值。你观察到了什么？

当将两个任务的优先级设置为相同值并且都固定在core 0上运行时，在示波器上观察到信号出现不稳定的情况：有时只能看到GPIO 19的信号而没有GPIO 23的信号，有时则相反只有GPIO 23的信号而没有GPIO 19的信号，这两种情况会不断反复切换，甚至出现震荡等各种不确定的状态。这是因为相同优先级的任务在同一个核心上运行时，FreeRTOS调度器会采用时间片轮转方式分配CPU时间，但由于任务没有主动让出CPU（没有延迟或阻塞操作），调度行为变得不可预测，导致某一时刻只有一个任务能够持续执行，而另一个任务被阻塞，并且这种状态会随机变化。

---

## 2.2 周期性任务

### 2.2.1 第一种方法

**程序：** IF4_TP1_Q22a.ino

#### 问题1：与前一个程序有什么区别？

与Q21b程序相比，Q22a的主要区别在于：首先，两个任务被分配到不同的核心上运行（Task1在core 0，Task2在core 1），避免了任务饥饿问题；其次，每个任务在完成工作循环（切换GPIO状态nb_iterations次）后都调用了`vTaskDelay()`函数，Task1延迟10ms，Task2延迟20ms，这样任务会主动让出CPU并进入阻塞状态，等待指定时间后再被唤醒继续执行，从而实现周期性执行的效果。

#### 问题2：任务1和任务2获得的周期是多少？解释原因。

通过示波器测量，GPIO 19（Task1）的信号周期约为26.8ms，GPIO 23（Task2）的信号周期约为36.8ms，这远大于预期的10ms和20ms周期。造成这个结果的原因是实际周期不仅包括`vTaskDelay()`设定的延迟时间，还包括任务的工作执行时间。每个任务需要完成nb_iterations=30000次GPIO切换操作后才会调用延迟函数，这个计算过程本身需要消耗大量时间。对于Task1，实际周期 = 工作时间（约16.8ms）+ 延迟时间（10ms）≈ 26.8ms；对于Task2，实际周期 = 工作时间（约16.8ms）+ 延迟时间（20ms）≈ 36.8ms。可以看到两个任务的工作时间基本相同（都是30000次循环），只是延迟时间不同，导致最终周期相差约10ms。

#### 问题3：如果强制两个任务在同一个核心上运行，会发生什么？

如果将两个任务都强制在同一个核心上运行，由于Task2的优先级（10）高于Task1的优先级（1），会出现以下情况：当Task1正在执行时，如果Task2的延迟时间到期需要运行，高优先级的Task2会立即抢占CPU，打断Task1的执行；Task2完成其工作循环并再次调用`vTaskDelay()`进入阻塞状态后，Task1才能继续执行；而当Task1还在执行工作时，如果Task2又被唤醒准备执行，Task2会再次立即抢占CPU打断Task1。这样导致Task1的执行被频繁打断，其实际周期会变得不稳定且可能显著增加，因为Task1不仅要完成自己的工作和延迟时间，还要额外承受被Task2多次抢占而暂停的时间。Task2的周期相对稳定，因为它总是优先执行不会被Task1打断，但由于和Task1共享CPU资源，其执行也可能受到轻微影响。

#### 问题4：预期周期是否得到遵守？这是获得周期性任务的好方法吗？

---
